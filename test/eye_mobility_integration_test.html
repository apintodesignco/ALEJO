<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ALEJO Eye Tracking + Mobility Assistance Integration Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      color: #333;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    .control-panel {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .panel {
      background-color: #f9f9f9;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .panel h2 {
      margin-top: 0;
      font-size: 18px;
      color: #444;
    }
    
    .toggle-group {
      margin-bottom: 10px;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin-right: 10px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #2196F3;
    }
    
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    .toggle-label {
      display: inline-block;
      vertical-align: middle;
      margin-left: 10px;
    }
    
    .video-container {
      position: relative;
      width: 100%;
      height: 480px;
      background-color: #000;
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    #videoElement {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    #gazeOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .target {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: rgba(255, 0, 0, 0.5);
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    
    .gaze-point {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: rgba(0, 255, 255, 0.7);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    
    .dwell-indicator {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 0, 0.7);
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .dwell-active {
      opacity: 1;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .log-container {
      height: 200px;
      overflow-y: auto;
      background-color: #222;
      color: #0f0;
      font-family: monospace;
      padding: 10px;
      border-radius: 4px;
    }
    
    .log-entry {
      margin: 0;
      padding: 2px 0;
      border-bottom: 1px solid #333;
    }
    
    .log-entry.info { color: #0f0; }
    .log-entry.warn { color: #ff0; }
    .log-entry.error { color: #f00; }
    .log-entry.debug { color: #0ff; }
    
    .mobility-profile {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }
    
    .profile-option {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    
    .profile-option label {
      margin-left: 10px;
    }
    
    .sensitivity-slider {
      width: 100%;
      margin: 10px 0;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    button {
      padding: 8px 16px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #0b7dda;
    }
    
    button.secondary {
      background-color: #f44336;
    }
    
    button.secondary:hover {
      background-color: #d32f2f;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ALEJO Eye Tracking + Mobility Assistance Integration Test</h1>
    
    <div class="control-panel">
      <div class="panel">
        <h2>Eye Tracking Controls</h2>
        <div class="toggle-group">
          <label class="toggle-switch">
            <input type="checkbox" id="eyeTrackingToggle">
            <span class="slider"></span>
          </label>
          <span class="toggle-label">Enable Eye Tracking</span>
        </div>
        
        <div class="toggle-group">
          <label class="toggle-switch">
            <input type="checkbox" id="dwellClickToggle">
            <span class="slider"></span>
          </label>
          <span class="toggle-label">Enable Dwell Clicking</span>
        </div>
        
        <div class="toggle-group">
          <label class="toggle-switch">
            <input type="checkbox" id="adaptiveModeToggle">
            <span class="slider"></span>
          </label>
          <span class="toggle-label">Adaptive Mode</span>
        </div>
        
        <div>
          <label for="dwellTimeSlider">Dwell Time (ms): <span id="dwellTimeValue">1000</span></label>
          <input type="range" id="dwellTimeSlider" class="sensitivity-slider" min="500" max="2000" step="100" value="1000">
        </div>
        
        <div class="button-group">
          <button id="calibrateButton">Calibrate</button>
          <button id="resetButton" class="secondary">Reset</button>
        </div>
      </div>
      
      <div class="panel">
        <h2>Mobility Profile</h2>
        <div class="mobility-profile">
          <div class="profile-option">
            <input type="checkbox" id="limitedMobilityCheck">
            <label for="limitedMobilityCheck">Has Limited Mobility</label>
          </div>
          
          <div class="profile-option">
            <input type="checkbox" id="canUseHandsCheck" checked>
            <label for="canUseHandsCheck">Can Use Hands</label>
          </div>
          
          <div>
            <label>Preferred Input Method:</label>
            <div class="profile-option">
              <input type="radio" name="inputMethod" id="handInput" value="hand" checked>
              <label for="handInput">Hand Gestures</label>
            </div>
            <div class="profile-option">
              <input type="radio" name="inputMethod" id="eyeInput" value="eye">
              <label for="eyeInput">Eye Control</label>
            </div>
            <div class="profile-option">
              <input type="radio" name="inputMethod" id="voiceInput" value="voice">
              <label for="voiceInput">Voice</label>
            </div>
          </div>
          
          <div>
            <label for="sensitivitySlider">Recognition Sensitivity: <span id="sensitivityValue">Medium</span></label>
            <input type="range" id="sensitivitySlider" class="sensitivity-slider" min="1" max="3" step="1" value="2">
          </div>
          
          <button id="applyProfileButton">Apply Profile</button>
        </div>
      </div>
      
      <div class="panel">
        <h2>Test Targets</h2>
        <button id="addTargetButton">Add Random Target</button>
        <button id="clearTargetsButton">Clear All Targets</button>
        <div>
          <label for="targetSizeSlider">Target Size: <span id="targetSizeValue">50</span>px</label>
          <input type="range" id="targetSizeSlider" class="sensitivity-slider" min="30" max="100" step="5" value="50">
        </div>
      </div>
    </div>
    
    <div class="video-container">
      <video id="videoElement" autoplay playsinline></video>
      <canvas id="gazeOverlay"></canvas>
      <div id="targetContainer"></div>
      <div id="gazePoint" class="gaze-point"></div>
      <div id="dwellIndicator" class="dwell-indicator"></div>
    </div>
    
    <div class="panel">
      <h2>Event Log</h2>
      <div id="logContainer" class="log-container"></div>
    </div>
  </div>

  <script type="module">
    // Import necessary modules
    import { publish, subscribe, unsubscribe } from '../src/events.js';
    import eyeProcessor from '../src/biometrics/eye/eye-processor.js';
    import mobilityAssistance from '../src/personalization/accessibility/mobility-assistance.js';
    
    // DOM elements
    const videoElement = document.getElementById('videoElement');
    const gazeOverlay = document.getElementById('gazeOverlay');
    const gazePoint = document.getElementById('gazePoint');
    const dwellIndicator = document.getElementById('dwellIndicator');
    const targetContainer = document.getElementById('targetContainer');
    const logContainer = document.getElementById('logContainer');
    
    // Control elements
    const eyeTrackingToggle = document.getElementById('eyeTrackingToggle');
    const dwellClickToggle = document.getElementById('dwellClickToggle');
    const adaptiveModeToggle = document.getElementById('adaptiveModeToggle');
    const dwellTimeSlider = document.getElementById('dwellTimeSlider');
    const dwellTimeValue = document.getElementById('dwellTimeValue');
    const calibrateButton = document.getElementById('calibrateButton');
    const resetButton = document.getElementById('resetButton');
    
    // Mobility profile elements
    const limitedMobilityCheck = document.getElementById('limitedMobilityCheck');
    const canUseHandsCheck = document.getElementById('canUseHandsCheck');
    const handInput = document.getElementById('handInput');
    const eyeInput = document.getElementById('eyeInput');
    const voiceInput = document.getElementById('voiceInput');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const sensitivityValue = document.getElementById('sensitivityValue');
    const applyProfileButton = document.getElementById('applyProfileButton');
    
    // Target elements
    const addTargetButton = document.getElementById('addTargetButton');
    const clearTargetsButton = document.getElementById('clearTargetsButton');
    const targetSizeSlider = document.getElementById('targetSizeSlider');
    const targetSizeValue = document.getElementById('targetSizeValue');
    
    // Canvas context
    const ctx = gazeOverlay.getContext('2d');
    
    // State
    let isEyeTrackingEnabled = false;
    let isDwellClickEnabled = false;
    let isAdaptiveModeEnabled = false;
    let targets = [];
    let targetSize = 50;
    
    // Initialize
    async function init() {
      // Set up canvas size
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Initialize eye processor
      try {
        await eyeProcessor.initialize({
          debugMode: true,
          processingInterval: 50,
          mobility: {
            adaptToLimitedMobility: false,
            isEyeControlPrimary: false,
            dwellClickEnabled: false,
            dwellTime: 1000,
            enhancedPrecision: false,
            sensitivityLevel: 'medium',
            autoCalibration: false
          }
        });
        log('info', 'Eye processor initialized successfully');
        
        // Initialize mobility assistance
        await mobilityAssistance.initialize({
          debug: true,
          adaptiveMode: false
        });
        log('info', 'Mobility assistance initialized successfully');
        
        // Set up camera
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: 'user'
            } 
          });
          videoElement.srcObject = stream;
          log('info', 'Camera access granted');
        } catch (error) {
          log('error', `Camera access denied: ${error.message}`);
        }
        
        // Set up event listeners
        setupEventListeners();
        
      } catch (error) {
        log('error', `Initialization error: ${error.message}`);
      }
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Subscribe to eye tracking events
      subscribe('eye:gaze:updated', handleGazeUpdate);
      subscribe('eye:blink:detected', handleBlinkDetected);
      subscribe('eye:dwell:completed', handleDwellCompleted);
      subscribe('eye:config:updated', handleConfigUpdate);
      
      // Subscribe to mobility assistance events
      subscribe('accessibility:mobility:profile_updated', handleMobilityProfileUpdate);
      
      // UI control event listeners
      eyeTrackingToggle.addEventListener('change', toggleEyeTracking);
      dwellClickToggle.addEventListener('change', toggleDwellClick);
      adaptiveModeToggle.addEventListener('change', toggleAdaptiveMode);
      dwellTimeSlider.addEventListener('input', updateDwellTime);
      calibrateButton.addEventListener('click', startCalibration);
      resetButton.addEventListener('click', resetSystem);
      
      // Mobility profile event listeners
      applyProfileButton.addEventListener('click', applyMobilityProfile);
      
      // Target event listeners
      addTargetButton.addEventListener('click', addRandomTarget);
      clearTargetsButton.addEventListener('click', clearAllTargets);
      targetSizeSlider.addEventListener('input', updateTargetSize);
      
      // Update UI based on initial values
      dwellTimeValue.textContent = dwellTimeSlider.value;
      targetSizeValue.textContent = targetSizeSlider.value;
      updateSensitivityLabel();
      
      log('info', 'Event listeners set up');
    }
    
    // Handle gaze update
    function handleGazeUpdate(data) {
      const { x, y, confidence, timestamp } = data;
      
      // Update gaze point position
      gazePoint.style.left = `${x}px`;
      gazePoint.style.top = `${y}px`;
      gazePoint.style.opacity = confidence;
      
      // Draw on canvas
      ctx.clearRect(0, 0, gazeOverlay.width, gazeOverlay.height);
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = `rgba(0, 255, 255, ${confidence})`;
      ctx.fill();
      
      // Check for target hits (for demonstration)
      checkTargetHits(x, y);
    }
    
    // Handle blink detection
    function handleBlinkDetected(data) {
      const { duration, strength } = data;
      log('debug', `Blink detected: ${duration.toFixed(2)}ms, strength: ${strength.toFixed(2)}`);
    }
    
    // Handle dwell completion
    function handleDwellCompleted(data) {
      const { x, y, timestamp } = data;
      
      // Visual feedback for dwell click
      dwellIndicator.style.left = `${x}px`;
      dwellIndicator.style.top = `${y}px`;
      dwellIndicator.classList.add('dwell-active');
      
      setTimeout(() => {
        dwellIndicator.classList.remove('dwell-active');
      }, 500);
      
      log('info', `Dwell click at (${x.toFixed(0)}, ${y.toFixed(0)})`);
      
      // Check if clicked on a target
      const clickedTarget = targets.find(target => {
        const dx = target.x - x;
        const dy = target.y - y;
        return Math.sqrt(dx * dx + dy * dy) <= targetSize / 2;
      });
      
      if (clickedTarget) {
        log('info', `Target ${clickedTarget.id} clicked!`);
        removeTarget(clickedTarget.id);
      }
    }
    
    // Handle config update
    function handleConfigUpdate(data) {
      log('debug', 'Eye processor config updated: ' + JSON.stringify(data));
      
      // Update UI based on new config
      if (data.mobility) {
        dwellClickToggle.checked = data.mobility.dwellClickEnabled;
        if (data.mobility.dwellTime) {
          dwellTimeSlider.value = data.mobility.dwellTime;
          dwellTimeValue.textContent = data.mobility.dwellTime;
        }
      }
    }
    
    // Handle mobility profile update
    function handleMobilityProfileUpdate(data) {
      const { profile } = data;
      log('info', 'Mobility profile updated: ' + JSON.stringify(profile));
      
      // Update UI based on profile
      limitedMobilityCheck.checked = profile.hasLimitedMobility;
      canUseHandsCheck.checked = profile.canUseHands;
      
      if (profile.preferredInputMethod === 'eye') {
        eyeInput.checked = true;
      } else if (profile.preferredInputMethod === 'voice') {
        voiceInput.checked = true;
      } else {
        handInput.checked = true;
      }
      
      // Update adaptive mode toggle
      adaptiveModeToggle.checked = profile.hasLimitedMobility;
    }
    
    // Toggle eye tracking
    function toggleEyeTracking() {
      isEyeTrackingEnabled = eyeTrackingToggle.checked;
      
      if (isEyeTrackingEnabled) {
        eyeProcessor.startProcessing();
        publish('accessibility:mobility:eye_control', { enabled: true });
        log('info', 'Eye tracking enabled');
      } else {
        eyeProcessor.stopProcessing();
        publish('accessibility:mobility:eye_control', { enabled: false });
        log('info', 'Eye tracking disabled');
      }
    }
    
    // Toggle dwell click
    function toggleDwellClick() {
      isDwellClickEnabled = dwellClickToggle.checked;
      
      publish('accessibility:mobility:dwell_click', { enabled: isDwellClickEnabled });
      log('info', `Dwell click ${isDwellClickEnabled ? 'enabled' : 'disabled'}`);
    }
    
    // Toggle adaptive mode
    function toggleAdaptiveMode() {
      isAdaptiveModeEnabled = adaptiveModeToggle.checked;
      
      publish('accessibility:mobility:adaptive_mode', { enabled: isAdaptiveModeEnabled });
      log('info', `Adaptive mode ${isAdaptiveModeEnabled ? 'enabled' : 'disabled'}`);
    }
    
    // Update dwell time
    function updateDwellTime() {
      const dwellTime = parseInt(dwellTimeSlider.value);
      dwellTimeValue.textContent = dwellTime;
      
      // Update eye processor config
      publish('settings:update', {
        category: 'accessibility',
        key: 'mobility',
        value: {
          dwellTime
        }
      });
      
      log('debug', `Dwell time updated to ${dwellTime}ms`);
    }
    
    // Start calibration
    function startCalibration() {
      eyeProcessor.startCalibration({
        points: 5,
        speed: 'normal'
      });
      
      log('info', 'Calibration started');
    }
    
    // Reset system
    function resetSystem() {
      eyeProcessor.stopProcessing();
      eyeTrackingToggle.checked = false;
      dwellClickToggle.checked = false;
      adaptiveModeToggle.checked = false;
      
      clearAllTargets();
      
      log('info', 'System reset');
    }
    
    // Apply mobility profile
    function applyMobilityProfile() {
      const profile = {
        hasLimitedMobility: limitedMobilityCheck.checked,
        canUseHands: canUseHandsCheck.checked,
        preferredInputMethod: handInput.checked ? 'hand' : (eyeInput.checked ? 'eye' : 'voice')
      };
      
      // Save profile to settings
      publish('settings:update', {
        category: 'accessibility',
        key: 'mobilityProfile',
        value: profile
      });
      
      // Notify mobility assistance
      publish('accessibility:mobility:profile_updated', { profile });
      
      log('info', 'Mobility profile applied: ' + JSON.stringify(profile));
    }
    
    // Update sensitivity label
    function updateSensitivityLabel() {
      const value = parseInt(sensitivitySlider.value);
      let label = 'Medium';
      
      if (value === 1) {
        label = 'Low';
      } else if (value === 3) {
        label = 'High';
      }
      
      sensitivityValue.textContent = label;
    }
    
    // Add random target
    function addRandomTarget() {
      const x = Math.random() * (gazeOverlay.width - 100) + 50;
      const y = Math.random() * (gazeOverlay.height - 100) + 50;
      const id = Date.now();
      
      const target = document.createElement('div');
      target.className = 'target';
      target.style.left = `${x}px`;
      target.style.top = `${y}px`;
      target.style.width = `${targetSize}px`;
      target.style.height = `${targetSize}px`;
      target.textContent = targets.length + 1;
      target.dataset.id = id;
      
      targetContainer.appendChild(target);
      
      targets.push({ id, x, y, element: target });
      
      log('debug', `Target added at (${x.toFixed(0)}, ${y.toFixed(0)})`);
    }
    
    // Clear all targets
    function clearAllTargets() {
      targets.forEach(target => {
        target.element.remove();
      });
      
      targets = [];
      log('debug', 'All targets cleared');
    }
    
    // Remove specific target
    function removeTarget(id) {
      const targetIndex = targets.findIndex(t => t.id === id);
      
      if (targetIndex !== -1) {
        targets[targetIndex].element.remove();
        targets.splice(targetIndex, 1);
      }
    }
    
    // Update target size
    function updateTargetSize() {
      targetSize = parseInt(targetSizeSlider.value);
      targetSizeValue.textContent = targetSize;
      
      targets.forEach(target => {
        target.element.style.width = `${targetSize}px`;
        target.element.style.height = `${targetSize}px`;
      });
    }
    
    // Check for target hits (visual feedback only)
    function checkTargetHits(x, y) {
      targets.forEach(target => {
        const dx = target.x - x;
        const dy = target.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= targetSize / 2) {
          target.element.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
        } else {
          target.element.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
        }
      });
    }
    
    // Resize canvas
    function resizeCanvas() {
      gazeOverlay.width = videoElement.clientWidth;
      gazeOverlay.height = videoElement.clientHeight;
    }
    
    // Log helper
    function log(level, message) {
      const entry = document.createElement('p');
      entry.className = `log-entry ${level}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      
      logContainer.prepend(entry);
      
      // Limit log entries
      if (logContainer.children.length > 100) {
        logContainer.removeChild(logContainer.lastChild);
      }
    }
    
    // Initialize on load
    window.addEventListener('load', init);
  </script>
</body>
</html>
